type: edu
custom_name: stage5
files:
- name: tests.py
  visible: false
  text: |
    from hstest.stage_test import StageTest
    from hstest.test_case import TestCase
    from hstest.check_result import CheckResult
    from threading import Thread
    from time import sleep
    import socket
    import random
    import json

    CheckResult.correct = lambda: CheckResult(True, '')
    CheckResult.wrong = lambda feedback: CheckResult(False, feedback)

    abc = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890'


    logins_list = [
        'admin', 'Admin', 'admin1', 'admin2', 'admin3',
        'user1', 'user2', 'root', 'default', 'new_user',
        'some_user', 'new_admin', 'administrator',
        'Administrator', 'superuser', 'super', 'su', 'alex',
        'suser', 'rootuser', 'adminadmin', 'useruser',
        'superadmin', 'username', 'username1'
    ]


    def logins():
        for login in logins_list:
            yield login


    def random_password():
        '''function - generating random password of length from 6 to 10'''
        return ''.join(random.choice(abc) for i in range(random.randint(6, 10)))


    def random_login():
        return random.choice(list(logins()))


    class TimeVulnerability(StageTest):

        def __init__(self, module):
            super().__init__(module)
            self.ready = False
            self.sock = None
            self.serv = None
            self.connected = False
            self.message = []
            self.password = None
            self.login = None

        def start_server(self):
            self.serv = Thread(target=lambda: self.server())
            self.serv.start()
            self.ready = False
            while not self.ready:
                sleep(0.1)  # socket needs to be set up before test

        def stop_server(self):
            self.sock.close()
            self.serv.join()

        def server(self):
            '''function - creating a server and answering clients'''
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self.sock.bind(('localhost', 9090))
            self.ready = True
            try:
                self.sock.listen(1)
                conn, addr = self.sock.accept()
                while True:
                    data = conn.recv(1024)
                    self.message.append(data.decode('utf8'))
                    self.connected = True
                    if len(self.message) > 100_000_000:
                        conn.send(json.dumps({'result': 'Too many attempts to connect!'}).encode('utf8'))
                        break
                    if not data:
                        break

                    try:
                        login_ = json.loads(data.decode('utf8'))['login']
                        password_ = json.loads(data.decode('utf8'))['password']
                    except:
                        conn.send(json.dumps({'result': 'Bad request!'}).encode('utf8'))
                        continue

                    if login_ == self.login:
                        if self.password == password_:
                            conn.send(json.dumps({'result': 'Connection success!'}).encode('utf8'))
                            break
                        elif self.password.startswith(password_):
                            sleep(0.1)
                            conn.send(json.dumps({'result': 'Wrong password!'}).encode('utf8'))
                        else:
                            conn.send(json.dumps({'result': 'Wrong password!'}).encode('utf8'))
                    else:
                        conn.send(json.dumps({'result': 'Wrong login!'}).encode('utf8'))
                conn.close()
            except:
                pass

        def generate(self):
            self.message = []
            self.password = random_password()
            self.login = random_login()
            self.start_server()
            return [
                TestCase(args=['localhost', '9090'],
                         attach=[self.password, self.login])
            ]

        def check(self, reply, attach):
            self.stop_server()

            if not self.connected:
                return CheckResult.wrong("You didn't connect to the server")

            real_password, real_login = attach
            try:
                json_reply = json.loads(reply)
            except:
                return CheckResult.wrong(
                    'The output of your program is not a valid JSON:\n' + reply
                )
            password = json_reply['password']
            login = json_reply['login']
            if login != real_login:
                return CheckResult.wrong('The login you printed is not correct')
            elif password != real_password:
                return CheckResult.wrong('The password you printed is not correct')
            find_first_letter = False
            for i in self.message:
                log = json.loads(i)['login']
                pas = json.loads(i)['password']
                if find_first_letter is False and len(pas) == 1 and log == real_login and real_password.startswith(pas):
                    find_first_letter = True
                if find_first_letter is True:
                    if log != real_login:
                        return CheckResult.wrong('You should find a correct login and then use only it')
                    if pas[0] != real_password[0]:
                        return CheckResult.wrong(
                            'When you find a first letter you should then start your passwords with it')
                if len(pas) > 1:
                    if pas[0:-1] != real_password[0:len(pas[0:-1]) - 1]:
                        return CheckResult.wrong(
                            'You have already found the first %d letters of the password. Use them as a beginning' % len(
                                pas[0:-1]))
                return CheckResult.correct()


    if __name__ == '__main__':
        test = TimeVulnerability('hacking.hack')
        test.run_tests()
        test.stop_server()
  learner_created: false
- name: hacking/hack.py
  visible: true
  text: "import sys\nimport socket\nimport itertools\nimport json\nimport string\n\
    \n\ndef passwords():\n    # with open('D:/Password Hacker/passwords.txt', 'r')\
    \ as file:\n    #     for line in file:\n    #         yield line.rstrip('\\n')\n\
    \    lst = list(string.ascii_letters)\n    lst.extend(list(string.digits))\n \
    \   for i in lst:\n        yield i\n\n\ndef login():\n    with open('D:/Password\
    \ Hacker1/logins.txt', 'r') as file:\n        for line in file:\n            yield\
    \ line.rstrip('\\n')\n\n\ndef hack():\n    h = {}\n    for log in login():\n \
    \       pa = passwords()\n        h[\"login\"] = log\n        passw = []\n   \
    \     for p in itertools.cycle(pa):\n            passw.append(p)\n           \
    \ h[\"password\"] = \"\".join(passw)\n            json_str = json.dumps(h, indent=4)\n\
    \n            json_s = json_str.encode()\n            cli_sock.send(json_s)\n\
    \            response = cli_sock.recv(1024)\n            response = json.loads(response.decode())\n\
    \n            r = response[\"result\"]\n            if r == \"Wrong login!\":\n\
    \                passw.pop()\n                break\n\n            elif r == \"\
    Wrong password!\":\n                passw.pop()\n                continue\n\n\
    \            elif r == \"Exception happened during login\":\n                continue\n\
    \n            elif r == \"Connection success!\":\n                print(json_str)\n\
    \                exit()\n\n\nargs = sys.argv\nwith socket.socket() as cli_sock:\n\
    \    ip_address = args[1]\n    port = int(args[2])\n    address = (ip_address,\
    \ port)\n    \n    cli_sock.connect(address)\n    hack()\n"
  learner_created: false
feedback_link: https://hyperskill.org/projects/80/stages/446/implement
status: Solved
record: 2
